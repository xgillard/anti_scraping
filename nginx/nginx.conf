# Cette configuration fait un peu plus que simplement faire du 
# reverse proxy ou du load balancing. En effet, on va demander à ngnix
# d'exécuter un peu de code lua pour vérifier que les utilisateurs sont
# bien authentifiés avant de pouvoir accéder aux ressoureces.
#
# On déclare les variables d'environnement pour que Lua puisse les lire
env JWT_SECRET;
env REDIS_HOST;
env REDIS_PORT;

worker_processes 1;

events {
     worker_connections 4096; 
     multi_accept on;
}

http {
    include       mime.types;
    default_type  application/octet-stream;
    
    # Cache du code Lua pour la perf
    lua_code_cache on;

    # Chargement des modules au démarrage
    init_by_lua_block {
        require "resty.core"
    }

    upstream agatha {
        server agatha.arch.be:443;
        keepalive 32;
    }

    upstream i3f {
        server i3f.arch.be:443;
    }

    server {
        listen 80;
        root /usr/local/openresty/nginx/html;

        # Frontend Mirador
        location / {
            index index.html;
            try_files $uri $uri/ /index.html;
        }

        # On intercepte toutes les requetes qui demandent à acceder à un 
        # manifest pour une ressource iiif (les json quoi) et on va les patcher
        # à la volée pour s'assurer que le manifest qui est renvoyé indique
        # bien qu'il faut nécessairement être connecté pour avoir accès à
        # nos données.
        location /data/json/ {
            content_by_lua_file /usr/local/openresty/nginx/lua/intercept_manifest.lua;
        }
     
        # Controle du fait qu'il faut être authentifié (avec un token jwt) 
        # pour pouvoir accéder aux ressources servies par le server iiif.
        location /iiif/ {
            # Ici on force l'execution de notre code lua avant de dire si on
            # autorise ou pas l'utilisateur à acceder à l'image qu'il demande.
            access_by_lua_file /usr/local/openresty/nginx/lua/protect_iiif.lua;
            # Si le script lua n'a pas tué la requete, ca veut dire qu'on 
            # autorise l'utilisateur à acceder à l'image qu'il veut.
            # Dans ce cas, on se contente alors de faire un proxy pass, cad
            # on forwarde sa requete vers le vrai server iif.
            proxy_pass https://i3f/iiif/;

            proxy_set_header Host i3f.arch.be;
            proxy_ssl_server_name on;
            proxy_ssl_name i3f.arch.be;
        }
     
        # Cette route sert à creer le token JWT si l'authentification 
        # est réussie sur agatha.
        location = /auth {
            content_by_lua_file /usr/local/openresty/nginx/lua/process_login.lua;
        }

        location = /token {
            content_by_lua_file  /usr/local/openresty/nginx/lua/iiif_auth_token.lua;
        }


        # Route interne pour que Lua puisse parler à Agatha (HTTPS)
        location /upstream_agatha/ {
            internal;
            # On retire le préfixe /upstream_agatha lors de l'envoi
            rewrite ^/upstream_agatha/(.*) /$1 break;
            
            proxy_pass https://agatha;
            proxy_ssl_server_name on; # Indispensable pour le HTTPS (SNI)
            proxy_set_header Host agatha.arch.be;
        }
        
        # Route interne pour parler au PHP de agatha (Invisible de l'extérieur)
        location /internal-php-login {
            internal;

            proxy_pass https://agatha/library/login.php;
            proxy_set_header Content-Type "application/x-www-form-urlencoded";
            proxy_set_header Host agatha.arch.be;
            proxy_ssl_server_name on;
            proxy_ssl_name agatha.arch.be;
        }

    }
}
